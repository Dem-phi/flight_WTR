# 1 原理概述

这两种方法的原理其实非常简单，了解一下有助于你调节参数，或者放着留给我来调参也可以。

## 1.1 PPS（Particle-Pair Search Method）

你看我取的名字多帅。看着真像那么回事。

随机生成m个粒子分布在二值化图像中，产生n个粒子对，要求每个粒子对中有一个在黑色区域，有一个在白色区域，然后每次迭代进行粒子对的二分逼近，实测一般8次左右的迭代就会完全锁定黑白边界。因此这个方法仅仅适用于二值化图像，要提前做图像分割。

消耗的算力非常小，demo中我使用了40个粒子对，10次迭代，仅仅消耗了3 ms左右的运算时间。所以力求精准度就可以随意加大粒子对数量。

## 1.2 MMCS（Mapping-based MSE optimization Search Method）

你看我取的名字多帅。看着真像那么回事。

这个要解决的问题就是把一堆散点找到中心。先将图像映射到另一个二维空间，给出先验的中心估计，内部和外部的杂点在这个空间中会明显分布在其他位置，也就是说有效点会高密度集中在一个区域，通过这个可以把内外杂点都剔除掉。然后将有效点与均值期望的均方误差作为损失函数进行梯度下降优化，优化结果就是一个期望中心。

这个方法好就好在他不是强行拟合一个圆，它能够允许点集呈现一个椭圆的样子，例如霍夫变换就会因为灰度图的色彩原因，导致拟合圆向某个方向“偏离”一点点，这种偏离导致实时运算时圆心会抖（我只是猜的，可能也不是这个原因）。

这个方法垃圾就垃圾在，他需要你给出先验的范围估计，并且图还不能很复杂，所以它仅仅很适用于咱们这个竞赛，并且只适用于精确对准，粗略找圆还是要用霍夫变换。（好吧，其实只需要在加一个聚类分析的环节就可以让它自适应剔除杂点。但是我太懒了，懒得写。）

梯度下降时我已经计算出了梯度的解析解，所以运算速度还是很快的，尝试过迭代1000次，用时仅仅10-20 ms，所以你可以放心大胆地修改优化过程。

# 2 使用方法以及参数介绍

## 2.1 PPS

### 2.1.1 图像预处理

这一次我并没有直接转化成灰度图，因为我发现在你给我的拍摄图中，由于光线阴影等等因素，灰度图中目标区域的灰度和周边光影的灰度相似度很高，很容易区分不开。我使用HSV空间的S通道进行二值化，经过我的测试，S通道对于色彩最为敏感，无论阴影光斑多么复杂，只要是颜色是白色-灰色那一类，统统都会被滤掉。就像下图，他为圆的边缘检测提供了精确的保障，甚至我认为你可以尝试去掉高斯滤波的环节，因为光影噪点已经没有了麻烦。

<img src="/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729164645082.png" alt="image-20210729164645082" style="zoom:50%;" />

当环境光出现色彩，例如场地使用黄色光，或者夕阳光线入射，可以在PPS的构造函数中调整二值化阈值，来修改对色彩的敏感度。

最牛逼的是，用色彩去做二值化，直接还可以把图案给滤掉

<img src="/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729173651132.png" alt="image-20210729173651132" style="zoom:50%;" />

原本中间是个人，但几乎都被滤没了。我原本还在想中间图案的圆会不会对霍夫变换造成干扰，现在不怕了。但是问题在于我尝试了很多次，把二值化图像给霍夫变换，它完全找不到圆，这让我很纳闷。

### 2.1.2 创建PPS类

```cpp
#include <PPS.h>

cv::Mat src = cv::imread("path")
PPS model(src);
model.is_debugging = false;
```

默认情况下只需要传入cv::Mat原始图像就可以了，但是有更多的参数可以调整

```cpp
PPS(cv::Mat src, int BinaryThreshold = 150, int resize_length = 500, int ParticlePair_num = 40, int max_iter = 10);
```

- BinaryThreshold： 已经没有啥用了，可以不管
- resize_length： 指定图像收缩的最长边长度，他会让图像最长的边变为这个长度，然后另一个边等比缩小，缩小可以提高运算速度。
- ParticlePair_num: 粒子对数量
- max_iter: 最大迭代次数

is_debugging属性默认是true，这种情况下会在关键步骤imshow出图像，方便你分析，不需要的时候改成false就行



### 2.1.3 找特征点

然后执行findFeaturePoints()来找特征点，需要创建一个std::vector<Eigen::Vector2f类型变量来接受，因为MMCS需要你把这个类型的变量输入进去，方便算。

```cpp
std::vector<Eigen::Vector2f> feature_points = model.findFeaturePoints();
```



## 2.2 MMCS

### 2.2.1 创建MMCS类

传入参数，同样有个is_debugging参数，默认是true

```cpp
#include <MMCS.h>
MMCS searcher(feature_points, Vector2f(model.src.cols/2,model.src.rows/2));
searcher.is_debugging = false;
```

```cpp
MMCS::MMCS(vector<Vector2f> feature_points, Vector2f prior_center, float scale)；
```

- feature_points: 就是上一步算出来的变量，直接扔进去
- prior_center: 先验的中心，由于我们是精对准采用，所以差不多把图像的中点扔进去就可以了，先验点越准，算的就越快，最终结果也越好
- scale: 是映射到另一个空间的放缩比，默认是1000.0，这个要怎么调后面会写。

### 2.2.2 排除噪点

排除噪点给两个浮点数，v_min和v_max，就是把原来的点映射到的空间中，有个关键坐标叫v，杂点的v值会显著在偏离的地方，给出一个范围用来确定有效点的v的范围。如果v_min == v_max，就会默认进行无约束排除，相当于不排除噪点。

```cpp
searcher.discard_noise(0, 30);
```

由于在固定高度对圆的时候，圆的位置几乎是确定的，所以可以在需要对准圆的高度拍范例图片，然后导入进去。设置is_debugging=true，并且v_min == v_max，该cpp文件的上级目录下创建V_sequence.txt，执行一次程序，就会把所有点的V值保存在txt文件中。然后肉眼看一下大多数点集中在哪个范围里面，就可以确定v_min 和 v_max了。

其实加一个聚类分析就可以自动确定范围了，但是我懒。或者说肉眼确定一下放心一点。

![image-20210729174147923](/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729174147923.png)上图这个例子是1.jpg的结果，你可以看到大多数点都在7-11之间，但是有极少数在1左右，这些点就是杂点，把v的范围设定在7-11就可以滤掉。

如果你设计了很多了粒子对，数据量可能很多，你用肉眼看不出来，我一般使用MATLAB绘图，在图上看很直观，python我也会绘图，但是cpp我不会，为了追求运算效率，我都是用cpp写的，代价就是数据分析真的很麻烦。

**另外**，之前有个scale=1000.0参数，其实就是把直接映射的v除以了1000，得到的结果就是上图的数，如果你把scale设置成10，结果就会变成v在700-1100之间，这会导致运算量很大。所以scale就是为了调整这个用的，如果某次测试你发现v过大，可以调一下scale，控制在0-100以内是比较好的。



### 2.2.3 梯度下降

```cpp
searcher.gradient_descend(0.01, 30);
```

然后执行梯度下降就好了。**第一个参数是学习率**，太大了容易优化崩，收敛不了，太小了收敛会很慢，只能硬调。其实我可以算一下二阶差分，然后进行自适应学习率优化，但是太麻烦，我不想再算数学了，这个老难算了。

你要是非要我算，我就后面再该好了。

**第二个参数是迭代次数**，debugging状态下应该会输出迭代优化过程辅助你调整迭代次数。

![image-20210729174917820](/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729174917820.png)

上图中MSE明显在不断下降，如果你发现迭代结束的时候还有下降趋势，就可以增加迭代次数。

![image-20210729175004331](/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729175004331.png)

上图中MSE几乎没有变化了，其实就是已经收敛了，要是收敛的数量太多，你完全可以减少迭代次数，来提高效率。1000次迭代才需要20 ms，很快，所以你不用担心优化的效率问题。实测一般来说只要你的v范围和先验中心给的够好，30次收敛绰绰有余。

### 2.2.4 拿到结果

访问searcher.center就可以直接拿到结果了。

## 2.3 输出量介绍

![image-20210729175215367](/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729175215367.png)

如果你的is_debugging都是true，会出现这些参数

- Optimized center: 优化中心
- N: 有效粒子对数目，也就是排除了杂点之后还有多少有效粒子对
- costs: 分别是三个方法的用时
- Hough circle: 霍夫变换算出的圆心



# 3 用PPS从B点找C点

<img src="/home/grandpadzb/cpp/circle_detector/readme.assets/image-20210729164645082.png" alt="image-20210729164645082" style="zoom:50%;" />

这个是PPS转化的图像，你可以看到尽管C点真的很小，用霍夫变换根本找不到，但是用PPS就可以发现它，但是问题在于场地以外也是有颜色的，而且面积还很大，所以粒子对基本都跑到那个变线上去了。

但是场地规模是定好的，只要我们提前设定了阈值，让例子不产生在边界以外，就可以在B点上空找到C点的位置，让飞机向C点飞了。

